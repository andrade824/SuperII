#ifndef CPU_H
#define CPU_H

#include <cstdint>
#include <string>
#include <vector>

#include "ireadwrite.h"

using std::string;
using std::vector;

// Helper macro for calling function pointers to member functions
#define CALL_MEMBER_FN(ptrToMember)  (this->*(ptrToMember))

/**
 * @brief Entity representing a single CPU instruction
 */
class Cpu;
struct CpuInstruction {
    string acronym;
    bool (Cpu::*addr_mode)(void);
    void (Cpu::*instr)(void);
    bool has_page_penalty;  // True if passing a page boundary adds a cycle
    uint8_t cycles;
    uint8_t size;   // Size in bytes (including opcode)
};

/**
 * @brief The excecution context for the CPU Core
 */
struct CpuContext {
    uint16_t pc;    // Program Counter
    uint8_t acc;    // Accumulator
    uint8_t x;      // X Index
    uint8_t y;      // Y Index
    uint8_t sp;     // Stack pointer
    uint8_t sr;     // Status Register
};

/**
 * @brief Bit mask values for the CPU flags
 */
enum CpuFlag {
    FLAG_CARRY = 0x1,
    FLAG_ZERO = 0x2,
    FLAG_IRQ = 0x4,
    FLAG_DECIMAL = 0x8,
    FLAG_BRK = 0x10,
    FLAG_UNUSED = 0x20,
    FLAG_OVERFLOW = 0x40,
    FLAG_NEGATIVE = 0x80
};

/**
 * @brief 6502 CPU Core
 */
class Cpu {
public:
    explicit Cpu(IReadWrite &bus, vector<CpuInstruction> &opcodes);
    // TODO: Copy constructor and assignment op overload

    // Reset the CPU to a valid starting point
    void Reset();

    // Execute a set number of instructions
    uint32_t Execute(uint32_t num_cycles);

    // Execute a single instruction
    void SingleStep();

    // TODO: IRQ and NMI

private:
    // Helper function for performing "16-bit" bus reads
    uint16_t bus_read16(uint16_t addr) const;

    // Helper function for saving an instruction result
    void save_result(uint16_t result);

    // Stack manipulation
    void push8(uint8_t value);
    void push16(uint16_t value);
    uint8_t pull8();
    uint16_t pull16();

    // Flag manipulation
    uint8_t get_flag(CpuFlag flag) const;
    void set_flag(CpuFlag flag, uint8_t value);

    void update_carry(uint16_t result);
    void update_zero(uint16_t result);
    void update_overflow(uint16_t result);
    void update_negative(uint16_t result);

    // Helper function for handling branches
    void do_branch(CpuFlag flag, uint8_t value);

public:
    // Addressing mode instructions
    bool addr_acc();
    bool addr_abs();
    bool addr_abs_x();
    bool addr_abs_y();
    bool addr_imm();
    bool addr_imp();
    bool addr_ind();
    bool addr_x_ind();
    bool addr_ind_y();
    bool addr_rel();
    bool addr_zpg();
    bool addr_zpg_x();
    bool addr_zpg_y();

    // Instruction functions
    void instr_adc();
    void instr_and();
    void instr_asl();
    void instr_bcc();
    void instr_bcs();
    void instr_beq();
    void instr_bit();
    void instr_bmi();
    void instr_bne();
    void instr_bpl();
    void instr_brk();
    void instr_bvc();
    void instr_bvs();
    void instr_clc();
    void instr_cld();
    void instr_cli();
    void instr_clv();
    void instr_cmp();
    void instr_cpx();
    void instr_cpy();
    void instr_dec();
    void instr_dex();
    void instr_dey();
    void instr_eor();
    void instr_inc();
    void instr_inx();
    void instr_iny();
    void instr_jmp();
    void instr_jsr();
    void instr_lda();
    void instr_ldx();
    void instr_ldy();
    void instr_lsr();
    void instr_nop();
    void instr_ora();
    void instr_pha();
    void instr_php();
    void instr_pla();
    void instr_plp();
    void instr_rol();
    void instr_ror();
    void instr_rti();
    void instr_rts();
    void instr_sbc();
    void instr_sec();
    void instr_sed();
    void instr_sei();
    void instr_sta();
    void instr_stx();
    void instr_sty();
    void instr_tax();
    void instr_tay();
    void instr_tsx();
    void instr_txa();
    void instr_txs();
    void instr_tya();

    // Undefined instruction
    void instr_und();

private:
    // Currently executing opcode
    uint8_t _cur_opcode = 0;

    // Number of instructions that have executed
    uint32_t _num_instr = 0;

    // Total number of cycles the processor has ran for
    uint32_t _total_cycles = 0;

    // Effective address generated by address mode
    uint16_t _effective_addr = 0;

    // Value calculated depending on addressing mode
    uint8_t _effective_value = 0;

    // System bus to perform read/write cycles on
    IReadWrite &_bus;

    // Base address of the stack
    const uint16_t _stack_base = 0x100;

    // Execution Context
    CpuContext _context { 0, 0, 0, 0, 0xFD, 0x20 };

    // CPU Instruction Table (256 total instructions)
    vector<CpuInstruction> &_opcodes;
};

#endif // CPU_H
